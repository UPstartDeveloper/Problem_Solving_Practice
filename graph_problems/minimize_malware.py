from collections import defaultdict, deque


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        """
        sq. adj. matrix --> graph ADT
        
        when a node is infected, it also infects all of its direct neighbors (if not already)
        
        spread stops when no more nodes can be infected
        
        inputs
        matrix = the network
        infected = ids of some nodes already infected
        
        Intuition:
            Goal - min the total # of nodes infected by the spread
                 - return the id of that node we could remove to min the spread
                 
        Approach
            1. Play Out Multiple Spread:
                1. for each infected
                    a) H: compute the final # of infected nodes, excluding that node [TODO]
                    b) map the final num --> ids that lead to that number
                2. return the id of the init ---> that min the final #
                
                ---------------
                Helper - initial
                a) computing the final number of infected nodes
                    input - 
                        list of ids,
                        adj matrix that shows connections between nodes
                        
                    A: init a dict, assume all the nodes (repr by id) are NOT infected (False)
                    B: BFS through the infected nodes, count up all the infected
                         b) BFS through the infected nodes 
                            c) mark them as infected in the dict
                            d) mark + enqueue their neighbors, if not already marked True 
                    C: use the dict to find the final # of infected - lowest value in lowest key 
                    
                    
        
        Edge Cases:
            - multiple nodes that could min ---> return the smallest id
            
        ---------------------
        Test Run:
        graph = [
              0 1. 2
          0  [1,1, 0],
          1  [0,1, 0],
          2  [0,0, 1],
        ]
            
        initial = [0,1]
        
        exclude_id = 0
        
        final_num_given_excluded_id = {
            2: [0, 1]
        }
        
        -------
        Helper, 1st call:
        
        helper_1_initial = q = []
        ---> 1, 0
        
        infected = {
            0: False, ---> True
            1: False, --> True
            2: False 
        }
        
        
        """
        """
        # A: compute how many infections each initial node cont.
        infections_per_initial = dict(zip(
                [node for node in initial], 
                [0 for _ in range(len(initial))]
        ))
        # B: BFS + prevent cycles
        infected_node_ids = dict(zip(
                list(range(len(graph))),
                [False for _ in range(len(graph))]
        ))
        q = deque(initial)
        # C: start BFS
        while len(q) > 0:
            infected_id = q.popleft()
            # c) mark them as infected in the dict
            infected_node_ids[infected_id] = True
            # d) mark + enqueue their neighbors, if not already marked True 
            for other_id in range(len(graph)):
                if graph[other_id][infected_id] == 1:
                    if infected_node_ids[other_id] is False:
                        q.append(other_id)
                        # also update the cont of the initial
                        if infected_id in infections_per_initial:
                            infections_per_initial[infected_id] += 1
        # D: return the smallest id amongast those that caused highest infections
        highest_contrib = max(infections_per_initial.values())
        lowest_initial_id = min([
            node_id for node_id in infections_per_initial.keys()
            if infections_per_initial[node_id] == highest_contrib
        ])
        return lowest_initial_id
        
        """
        
        def compute_final_infected(excluded_id):
            # A: init a dict, assume all the nodes (repr by id) are NOT infected (False)
            infected_node_ids = dict(zip(
                list(range(len(graph))),
                [False for _ in range(len(graph))]
            ))
            # B: BFS through the infected nodes, count up all the infected
            q = deque([val for val in initial if val != excluded_id])
            # b) BFS through the infected nodes 
            while len(q) > 0:
                infected_id = q.popleft()
                # c) mark them as infected in the dict
                infected_node_ids[infected_id] = True
                # d) mark + enqueue their neighbors, if not already marked True 
                for other_id in range(len(graph)):
                    if graph[other_id][infected_id] == 1:
                        if infected_node_ids[other_id] is False:
                            q.append(other_id)
            # C: use the dict to find the final # of infected - lowest value in lowest key 
            count = sum(list(infected_node_ids.values()))
            return count
        
        # init dict 
        final_num_given_excluded_id = defaultdict(list)
        # 1. for each infected
        for excluded_id in initial:
            # a) H: compute the final # of infected nodes, excluding that node [TODO]
            final_infected = compute_final_infected(excluded_id)
            # b) map the final num --> ids that lead to that number
            final_num_given_excluded_id[final_infected].append(excluded_id)
        # 2. return the id of the init ---> that min the final #
        minimum_infected = min(list(final_num_given_excluded_id.keys()))
        return min(final_num_given_excluded_id[minimum_infected])
        
    
"""
graph = [
      0 1.2 
   0 [1,1,0],
   1 [1,1,0],
   2 [0,0,1]
], 

initial = [0,1]
           ^

final_num_given_excluded_id = {
    2: [0, ]
}


excluded_id     remaining_initial = q      final_infected
0                   []                       2


infected_node_ids = {
    0: F --> T --> 1
    1: F --> T --> 1
    2: F --------> 0
}

infected_id = 1, 0     other_id = 0, 1, 2, 0, 1, 2
                        
"""
        